"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSingleInputDateRangeField = exports.useDefaultizedDateRangeFieldProps = exports.dateRangeFieldValueManager = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _internals = require("@mui/x-date-pickers/internals");

var _internalsFields = require("@mui/x-date-pickers/internals-fields");

var _shared = require("../DateRangePicker/shared");

var _SingleInputDateRangeField = require("./SingleInputDateRangeField.utils");

var _useDateRangeValidation = require("../internal/hooks/validation/useDateRangeValidation");

const _excluded = ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "minDate", "maxDate", "disableFuture", "disablePast"];
const dateRangeFieldValueManager = {
  getSectionsFromValue: (utils, prevSections, [start, end], format) => {
    const prevDateRangeSections = prevSections == null ? {
      startDate: null,
      endDate: null
    } : (0, _SingleInputDateRangeField.splitDateRangeSections)(prevSections);

    const getSections = (newDate, prevDateSections) => {
      const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!prevDateSections;

      if (shouldReUsePrevDateSections) {
        return prevDateSections;
      }

      return (0, _internalsFields.splitFormatIntoSections)(utils, format, newDate);
    };

    const rawSectionsOfStartDate = getSections(start, prevDateRangeSections.startDate);
    const rawSectionsOfEndDate = getSections(end, prevDateRangeSections.endDate);
    const sectionsOfStartDate = rawSectionsOfStartDate.map((section, sectionIndex) => {
      if (sectionIndex === rawSectionsOfStartDate.length - 1) {
        return (0, _extends2.default)({}, section, {
          dateName: 'start',
          separator: ' â€“ '
        });
      }

      return (0, _extends2.default)({}, section, {
        dateName: 'start'
      });
    });
    const sectionsOfEndDate = rawSectionsOfEndDate.map(section => (0, _extends2.default)({}, section, {
      dateName: 'end'
    }));
    return (0, _internalsFields.addPositionPropertiesToSections)([...sectionsOfStartDate, ...sectionsOfEndDate]);
  },
  getValueStrFromSections: sections => {
    const dateRangeSections = (0, _SingleInputDateRangeField.splitDateRangeSections)(sections);
    const startDateStr = (0, _internalsFields.createDateStrFromSections)(dateRangeSections.startDate);
    const endDateStr = (0, _internalsFields.createDateStrFromSections)(dateRangeSections.endDate);
    return `${startDateStr}${endDateStr}`;
  },
  getValueFromSections: (utils, prevSections, newSections, format) => {
    const removeLastSeparator = sections => sections.map((section, sectionIndex) => {
      if (sectionIndex === sections.length - 1) {
        return (0, _extends2.default)({}, section, {
          separator: null
        });
      }

      return section;
    });

    const prevDateRangeSections = (0, _SingleInputDateRangeField.splitDateRangeSections)(prevSections);
    const dateRangeSections = (0, _SingleInputDateRangeField.splitDateRangeSections)(newSections);
    const startDateStr = (0, _internalsFields.createDateStrFromSections)(removeLastSeparator(dateRangeSections.startDate));
    const endDateStr = (0, _internalsFields.createDateStrFromSections)(dateRangeSections.endDate);
    const startDate = utils.parse(startDateStr, format);
    const endDate = utils.parse(endDateStr, format);
    const shouldPublish = startDateStr !== (0, _internalsFields.createDateStrFromSections)(removeLastSeparator(prevDateRangeSections.startDate)) && utils.isValid(startDate) || endDateStr !== (0, _internalsFields.createDateStrFromSections)(prevDateRangeSections.endDate) && utils.isValid(endDate);
    return {
      value: [startDate, endDate],
      shouldPublish
    };
  },
  getActiveDateFromActiveSection: (value, activeSection) => {
    const updateActiveDate = dateName => newActiveDate => {
      if (dateName === 'start') {
        return [newActiveDate, value[1]];
      }

      return [value[0], newActiveDate];
    };

    if (activeSection.dateName === 'start') {
      return {
        value: value[0],
        update: updateActiveDate('start')
      };
    }

    return {
      value: value[1],
      update: updateActiveDate('end')
    };
  },
  hasError: error => error[0] != null || error[1] != null,
  isSameError: _useDateRangeValidation.isSameDateRangeError
};
exports.dateRangeFieldValueManager = dateRangeFieldValueManager;

const useDefaultizedDateRangeFieldProps = props => {
  const utils = (0, _internals.useUtils)();
  const defaultDates = (0, _internals.useDefaultDates)();
  return (0, _extends2.default)({
    disablePast: false,
    disableFuture: false
  }, props, {
    minDate: (0, _internals.parseNonNullablePickerDate)(utils, props.minDate, defaultDates.minDate),
    maxDate: (0, _internals.parseNonNullablePickerDate)(utils, props.maxDate, defaultDates.maxDate)
  });
};

exports.useDefaultizedDateRangeFieldProps = useDefaultizedDateRangeFieldProps;

const useSingleInputDateRangeField = inProps => {
  const _useDefaultizedDateRa = useDefaultizedDateRangeFieldProps(inProps),
        {
    value,
    defaultValue,
    format,
    onChange,
    readOnly,
    onError,
    shouldDisableDate,
    minDate,
    maxDate,
    disableFuture,
    disablePast
  } = _useDefaultizedDateRa,
        other = (0, _objectWithoutPropertiesLoose2.default)(_useDefaultizedDateRa, _excluded);

  return (0, _internalsFields.useField)({
    forwardedProps: other,
    internalProps: {
      value,
      defaultValue,
      format,
      onChange,
      readOnly,
      onError,
      shouldDisableDate,
      minDate,
      maxDate,
      disableFuture,
      disablePast
    },
    valueManager: _shared.dateRangePickerValueManager,
    fieldValueManager: dateRangeFieldValueManager,
    validator: _useDateRangeValidation.validateDateRange
  });
};

exports.useSingleInputDateRangeField = useSingleInputDateRangeField;