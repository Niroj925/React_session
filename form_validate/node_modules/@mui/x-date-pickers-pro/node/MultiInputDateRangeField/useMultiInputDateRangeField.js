"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMultiInputDateRangeField = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _useEventCallback = _interopRequireDefault(require("@mui/utils/useEventCallback"));

var _DateField = require("@mui/x-date-pickers/DateField");

var _internals = require("@mui/x-date-pickers/internals");

var _useDateRangeValidation = require("../internal/hooks/validation/useDateRangeValidation");

var _shared = require("../DateRangePicker/shared");

var _useSingleInputDateRangeField = require("../SingleInputDateRangeField/useSingleInputDateRangeField");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const useMultiInputDateRangeField = inProps => {
  var _ref;

  const props = (0, _useSingleInputDateRangeField.useDefaultizedDateRangeFieldProps)(inProps);
  const utils = (0, _internals.useUtils)();
  const {
    value: valueProp,
    defaultValue,
    format,
    onChange
  } = props;
  const firstDefaultValue = React.useRef(defaultValue); // TODO: Maybe export utility from `useField` instead of copy/pasting the logic

  const buildChangeHandler = index => {
    if (!onChange) {
      return () => {};
    }

    return newDate => {
      let newDateRange;

      if (valueProp !== undefined) {
        newDateRange = _shared.dateRangePickerValueManager.parseInput(utils, valueProp);
      } else if (firstDefaultValue.current !== undefined) {
        newDateRange = _shared.dateRangePickerValueManager.parseInput(utils, firstDefaultValue.current);
      } else {
        newDateRange = _shared.dateRangePickerValueManager.emptyValue;
      }

      newDateRange[index] = newDate;
      onChange(newDateRange);
    };
  };

  const handleStartDateChange = (0, _useEventCallback.default)(buildChangeHandler(0));
  const handleEndDateChange = (0, _useEventCallback.default)(buildChangeHandler(1));
  const startInputProps = {
    format,
    value: valueProp === undefined ? undefined : valueProp[0],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[0],
    onChange: handleStartDateChange
  };
  const endInputProps = {
    format,
    value: valueProp === undefined ? undefined : valueProp[1],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[1],
    onChange: handleEndDateChange
  };
  const rawStartDateResponse = (0, _DateField.unstable_useDateField)(startInputProps);
  const rawEndDateResponse = (0, _DateField.unstable_useDateField)(endInputProps); // TODO: Avoid the type casting.

  const value = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : _shared.dateRangePickerValueManager.emptyValue;
  const validationError = (0, _internals.useValidation)((0, _extends2.default)({}, props, {
    value
  }), _useDateRangeValidation.validateDateRange, () => true);
  const inputError = React.useMemo(() => _useSingleInputDateRangeField.dateRangeFieldValueManager.hasError(validationError), [validationError]);
  const startDateResponse = (0, _extends2.default)({}, rawStartDateResponse, {
    inputProps: (0, _extends2.default)({}, rawStartDateResponse.inputProps, {
      error: inputError
    })
  });
  const endDateResponse = (0, _extends2.default)({}, rawEndDateResponse, {
    inputProps: (0, _extends2.default)({}, rawEndDateResponse.inputProps, {
      error: inputError
    })
  });
  return {
    startDate: startDateResponse,
    endDate: endDateResponse
  };
};

exports.useMultiInputDateRangeField = useMultiInputDateRangeField;