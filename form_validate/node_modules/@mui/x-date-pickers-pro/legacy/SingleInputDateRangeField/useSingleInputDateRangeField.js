import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
var _excluded = ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "minDate", "maxDate", "disableFuture", "disablePast"];
import { useUtils, useDefaultDates, parseNonNullablePickerDate } from '@mui/x-date-pickers/internals';
import { useField, splitFormatIntoSections, addPositionPropertiesToSections, createDateStrFromSections } from '@mui/x-date-pickers/internals-fields';
import { dateRangePickerValueManager } from '../DateRangePicker/shared';
import { splitDateRangeSections } from './SingleInputDateRangeField.utils';
import { isSameDateRangeError, validateDateRange } from '../internal/hooks/validation/useDateRangeValidation';
export var dateRangeFieldValueManager = {
  getSectionsFromValue: function getSectionsFromValue(utils, prevSections, _ref, format) {
    var _ref2 = _slicedToArray(_ref, 2),
        start = _ref2[0],
        end = _ref2[1];

    var prevDateRangeSections = prevSections == null ? {
      startDate: null,
      endDate: null
    } : splitDateRangeSections(prevSections);

    var getSections = function getSections(newDate, prevDateSections) {
      var shouldReUsePrevDateSections = !utils.isValid(newDate) && !!prevDateSections;

      if (shouldReUsePrevDateSections) {
        return prevDateSections;
      }

      return splitFormatIntoSections(utils, format, newDate);
    };

    var rawSectionsOfStartDate = getSections(start, prevDateRangeSections.startDate);
    var rawSectionsOfEndDate = getSections(end, prevDateRangeSections.endDate);
    var sectionsOfStartDate = rawSectionsOfStartDate.map(function (section, sectionIndex) {
      if (sectionIndex === rawSectionsOfStartDate.length - 1) {
        return _extends({}, section, {
          dateName: 'start',
          separator: ' â€“ '
        });
      }

      return _extends({}, section, {
        dateName: 'start'
      });
    });
    var sectionsOfEndDate = rawSectionsOfEndDate.map(function (section) {
      return _extends({}, section, {
        dateName: 'end'
      });
    });
    return addPositionPropertiesToSections([].concat(_toConsumableArray(sectionsOfStartDate), _toConsumableArray(sectionsOfEndDate)));
  },
  getValueStrFromSections: function getValueStrFromSections(sections) {
    var dateRangeSections = splitDateRangeSections(sections);
    var startDateStr = createDateStrFromSections(dateRangeSections.startDate);
    var endDateStr = createDateStrFromSections(dateRangeSections.endDate);
    return "".concat(startDateStr).concat(endDateStr);
  },
  getValueFromSections: function getValueFromSections(utils, prevSections, newSections, format) {
    var removeLastSeparator = function removeLastSeparator(sections) {
      return sections.map(function (section, sectionIndex) {
        if (sectionIndex === sections.length - 1) {
          return _extends({}, section, {
            separator: null
          });
        }

        return section;
      });
    };

    var prevDateRangeSections = splitDateRangeSections(prevSections);
    var dateRangeSections = splitDateRangeSections(newSections);
    var startDateStr = createDateStrFromSections(removeLastSeparator(dateRangeSections.startDate));
    var endDateStr = createDateStrFromSections(dateRangeSections.endDate);
    var startDate = utils.parse(startDateStr, format);
    var endDate = utils.parse(endDateStr, format);
    var shouldPublish = startDateStr !== createDateStrFromSections(removeLastSeparator(prevDateRangeSections.startDate)) && utils.isValid(startDate) || endDateStr !== createDateStrFromSections(prevDateRangeSections.endDate) && utils.isValid(endDate);
    return {
      value: [startDate, endDate],
      shouldPublish: shouldPublish
    };
  },
  getActiveDateFromActiveSection: function getActiveDateFromActiveSection(value, activeSection) {
    var updateActiveDate = function updateActiveDate(dateName) {
      return function (newActiveDate) {
        if (dateName === 'start') {
          return [newActiveDate, value[1]];
        }

        return [value[0], newActiveDate];
      };
    };

    if (activeSection.dateName === 'start') {
      return {
        value: value[0],
        update: updateActiveDate('start')
      };
    }

    return {
      value: value[1],
      update: updateActiveDate('end')
    };
  },
  hasError: function hasError(error) {
    return error[0] != null || error[1] != null;
  },
  isSameError: isSameDateRangeError
};
export var useDefaultizedDateRangeFieldProps = function useDefaultizedDateRangeFieldProps(props) {
  var utils = useUtils();
  var defaultDates = useDefaultDates();
  return _extends({
    disablePast: false,
    disableFuture: false
  }, props, {
    minDate: parseNonNullablePickerDate(utils, props.minDate, defaultDates.minDate),
    maxDate: parseNonNullablePickerDate(utils, props.maxDate, defaultDates.maxDate)
  });
};
export var useSingleInputDateRangeField = function useSingleInputDateRangeField(inProps) {
  var _useDefaultizedDateRa = useDefaultizedDateRangeFieldProps(inProps),
      value = _useDefaultizedDateRa.value,
      defaultValue = _useDefaultizedDateRa.defaultValue,
      format = _useDefaultizedDateRa.format,
      onChange = _useDefaultizedDateRa.onChange,
      readOnly = _useDefaultizedDateRa.readOnly,
      onError = _useDefaultizedDateRa.onError,
      shouldDisableDate = _useDefaultizedDateRa.shouldDisableDate,
      minDate = _useDefaultizedDateRa.minDate,
      maxDate = _useDefaultizedDateRa.maxDate,
      disableFuture = _useDefaultizedDateRa.disableFuture,
      disablePast = _useDefaultizedDateRa.disablePast,
      other = _objectWithoutProperties(_useDefaultizedDateRa, _excluded);

  return useField({
    forwardedProps: other,
    internalProps: {
      value: value,
      defaultValue: defaultValue,
      format: format,
      onChange: onChange,
      readOnly: readOnly,
      onError: onError,
      shouldDisableDate: shouldDisableDate,
      minDate: minDate,
      maxDate: maxDate,
      disableFuture: disableFuture,
      disablePast: disablePast
    },
    valueManager: dateRangePickerValueManager,
    fieldValueManager: dateRangeFieldValueManager,
    validator: validateDateRange
  });
};