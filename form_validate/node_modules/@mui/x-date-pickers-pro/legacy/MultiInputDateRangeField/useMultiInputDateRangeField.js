import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import useEventCallback from '@mui/utils/useEventCallback';
import { unstable_useDateField as useDateField } from '@mui/x-date-pickers/DateField';
import { useUtils, useValidation } from '@mui/x-date-pickers/internals';
import { validateDateRange } from '../internal/hooks/validation/useDateRangeValidation';
import { dateRangePickerValueManager } from '../DateRangePicker/shared';
import { dateRangeFieldValueManager, useDefaultizedDateRangeFieldProps } from '../SingleInputDateRangeField/useSingleInputDateRangeField';
export var useMultiInputDateRangeField = function useMultiInputDateRangeField(inProps) {
  var _ref;

  var props = useDefaultizedDateRangeFieldProps(inProps);
  var utils = useUtils();
  var valueProp = props.value,
      defaultValue = props.defaultValue,
      format = props.format,
      onChange = props.onChange;
  var firstDefaultValue = React.useRef(defaultValue); // TODO: Maybe export utility from `useField` instead of copy/pasting the logic

  var buildChangeHandler = function buildChangeHandler(index) {
    if (!onChange) {
      return function () {};
    }

    return function (newDate) {
      var newDateRange;

      if (valueProp !== undefined) {
        newDateRange = dateRangePickerValueManager.parseInput(utils, valueProp);
      } else if (firstDefaultValue.current !== undefined) {
        newDateRange = dateRangePickerValueManager.parseInput(utils, firstDefaultValue.current);
      } else {
        newDateRange = dateRangePickerValueManager.emptyValue;
      }

      newDateRange[index] = newDate;
      onChange(newDateRange);
    };
  };

  var handleStartDateChange = useEventCallback(buildChangeHandler(0));
  var handleEndDateChange = useEventCallback(buildChangeHandler(1));
  var startInputProps = {
    format: format,
    value: valueProp === undefined ? undefined : valueProp[0],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[0],
    onChange: handleStartDateChange
  };
  var endInputProps = {
    format: format,
    value: valueProp === undefined ? undefined : valueProp[1],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[1],
    onChange: handleEndDateChange
  };
  var rawStartDateResponse = useDateField(startInputProps);
  var rawEndDateResponse = useDateField(endInputProps); // TODO: Avoid the type casting.

  var value = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : dateRangePickerValueManager.emptyValue;
  var validationError = useValidation(_extends({}, props, {
    value: value
  }), validateDateRange, function () {
    return true;
  });
  var inputError = React.useMemo(function () {
    return dateRangeFieldValueManager.hasError(validationError);
  }, [validationError]);

  var startDateResponse = _extends({}, rawStartDateResponse, {
    inputProps: _extends({}, rawStartDateResponse.inputProps, {
      error: inputError
    })
  });

  var endDateResponse = _extends({}, rawEndDateResponse, {
    inputProps: _extends({}, rawEndDateResponse.inputProps, {
      error: inputError
    })
  });

  return {
    startDate: startDateResponse,
    endDate: endDateResponse
  };
};