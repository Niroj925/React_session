import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import useEventCallback from '@mui/utils/useEventCallback';
import { unstable_useDateField as useDateField } from '@mui/x-date-pickers/DateField';
import { useUtils, useValidation } from '@mui/x-date-pickers/internals';
import { validateDateRange } from '../internal/hooks/validation/useDateRangeValidation';
import { dateRangePickerValueManager } from '../DateRangePicker/shared';
import { dateRangeFieldValueManager, useDefaultizedDateRangeFieldProps } from '../SingleInputDateRangeField/useSingleInputDateRangeField';
export const useMultiInputDateRangeField = inProps => {
  var _ref;

  const props = useDefaultizedDateRangeFieldProps(inProps);
  const utils = useUtils();
  const {
    value: valueProp,
    defaultValue,
    format,
    onChange
  } = props;
  const firstDefaultValue = React.useRef(defaultValue); // TODO: Maybe export utility from `useField` instead of copy/pasting the logic

  const buildChangeHandler = index => {
    if (!onChange) {
      return () => {};
    }

    return newDate => {
      let newDateRange;

      if (valueProp !== undefined) {
        newDateRange = dateRangePickerValueManager.parseInput(utils, valueProp);
      } else if (firstDefaultValue.current !== undefined) {
        newDateRange = dateRangePickerValueManager.parseInput(utils, firstDefaultValue.current);
      } else {
        newDateRange = dateRangePickerValueManager.emptyValue;
      }

      newDateRange[index] = newDate;
      onChange(newDateRange);
    };
  };

  const handleStartDateChange = useEventCallback(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback(buildChangeHandler(1));
  const startInputProps = {
    format,
    value: valueProp === undefined ? undefined : valueProp[0],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[0],
    onChange: handleStartDateChange
  };
  const endInputProps = {
    format,
    value: valueProp === undefined ? undefined : valueProp[1],
    defaultValue: defaultValue === undefined ? undefined : defaultValue[1],
    onChange: handleEndDateChange
  };
  const rawStartDateResponse = useDateField(startInputProps);
  const rawEndDateResponse = useDateField(endInputProps); // TODO: Avoid the type casting.

  const value = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : dateRangePickerValueManager.emptyValue;
  const validationError = useValidation(_extends({}, props, {
    value
  }), validateDateRange, () => true);
  const inputError = React.useMemo(() => dateRangeFieldValueManager.hasError(validationError), [validationError]);

  const startDateResponse = _extends({}, rawStartDateResponse, {
    inputProps: _extends({}, rawStartDateResponse.inputProps, {
      error: inputError
    })
  });

  const endDateResponse = _extends({}, rawEndDateResponse, {
    inputProps: _extends({}, rawEndDateResponse.inputProps, {
      error: inputError
    })
  });

  return {
    startDate: startDateResponse,
    endDate: endDateResponse
  };
};