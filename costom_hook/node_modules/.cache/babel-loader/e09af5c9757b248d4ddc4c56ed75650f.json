{"ast":null,"code":"import { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './misc/hookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n  if (capacity === void 0) {\n    capacity = 10;\n  }\n\n  if (capacity < 1) {\n    throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n  }\n\n  var isFirstMount = useFirstMountState();\n\n  var _a = useState(initialState),\n      state = _a[0],\n      innerSetState = _a[1];\n\n  var history = useRef(initialHistory !== null && initialHistory !== void 0 ? initialHistory : []);\n  var historyPosition = useRef(0); // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n\n  if (isFirstMount) {\n    if (history.current.length) {\n      // if last element of history !== initial - push initial to history\n      if (history.current[history.current.length - 1] !== initialState) {\n        history.current.push(initialState);\n      } // if initial history bigger that capacity - crop the first elements out\n\n\n      if (history.current.length > capacity) {\n        history.current = history.current.slice(history.current.length - capacity);\n      }\n    } else {\n      // initiate the history with initial state\n      history.current.push(initialState);\n    }\n\n    historyPosition.current = history.current.length && history.current.length - 1;\n  }\n\n  var setState = useCallback(function (newState) {\n    innerSetState(function (currentState) {\n      newState = resolveHookState(newState, currentState); // is state has changed\n\n      if (newState !== currentState) {\n        // if current position is not the last - pop element to the right\n        if (historyPosition.current < history.current.length - 1) {\n          history.current = history.current.slice(0, historyPosition.current + 1);\n        }\n\n        historyPosition.current = history.current.push(newState) - 1; // if capacity is reached - shift first elements\n\n        if (history.current.length > capacity) {\n          history.current = history.current.slice(history.current.length - capacity);\n        }\n      }\n\n      return newState;\n    });\n  }, [state, capacity]);\n  var historyState = useMemo(function () {\n    return {\n      history: history.current,\n      position: historyPosition.current,\n      capacity: capacity,\n      back: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the left border\n\n\n        if (!historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current -= Math.min(amount, historyPosition.current);\n          return history.current[historyPosition.current];\n        });\n      },\n      forward: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the right border\n\n\n        if (historyPosition.current === history.current.length - 1) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n          return history.current[historyPosition.current];\n        });\n      },\n      go: function (position) {\n        if (position === historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = position < 0 ? Math.max(history.current.length + position, 0) : Math.min(history.current.length - 1, position);\n          return history.current[historyPosition.current];\n        });\n      }\n    };\n  }, [state]);\n  return [state, setState, historyState];\n}","map":{"version":3,"names":["useCallback","useMemo","useRef","useState","useFirstMountState","resolveHookState","useStateWithHistory","initialState","capacity","initialHistory","Error","isFirstMount","_a","state","innerSetState","history","historyPosition","current","length","push","slice","setState","newState","currentState","historyState","position","back","amount","Math","min","forward","go","max"],"sources":["/home/neo-j-thapa/Documents/React/costom_hook/node_modules/react-use/esm/useStateWithHistory.js"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './misc/hookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n    if (capacity === void 0) { capacity = 10; }\n    if (capacity < 1) {\n        throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n    }\n    var isFirstMount = useFirstMountState();\n    var _a = useState(initialState), state = _a[0], innerSetState = _a[1];\n    var history = useRef((initialHistory !== null && initialHistory !== void 0 ? initialHistory : []));\n    var historyPosition = useRef(0);\n    // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n    if (isFirstMount) {\n        if (history.current.length) {\n            // if last element of history !== initial - push initial to history\n            if (history.current[history.current.length - 1] !== initialState) {\n                history.current.push(initialState);\n            }\n            // if initial history bigger that capacity - crop the first elements out\n            if (history.current.length > capacity) {\n                history.current = history.current.slice(history.current.length - capacity);\n            }\n        }\n        else {\n            // initiate the history with initial state\n            history.current.push(initialState);\n        }\n        historyPosition.current = history.current.length && history.current.length - 1;\n    }\n    var setState = useCallback(function (newState) {\n        innerSetState(function (currentState) {\n            newState = resolveHookState(newState, currentState);\n            // is state has changed\n            if (newState !== currentState) {\n                // if current position is not the last - pop element to the right\n                if (historyPosition.current < history.current.length - 1) {\n                    history.current = history.current.slice(0, historyPosition.current + 1);\n                }\n                historyPosition.current = history.current.push(newState) - 1;\n                // if capacity is reached - shift first elements\n                if (history.current.length > capacity) {\n                    history.current = history.current.slice(history.current.length - capacity);\n                }\n            }\n            return newState;\n        });\n    }, [state, capacity]);\n    var historyState = useMemo(function () { return ({\n        history: history.current,\n        position: historyPosition.current,\n        capacity: capacity,\n        back: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the left border\n            if (!historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current -= Math.min(amount, historyPosition.current);\n                return history.current[historyPosition.current];\n            });\n        },\n        forward: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the right border\n            if (historyPosition.current === history.current.length - 1) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n                return history.current[historyPosition.current];\n            });\n        },\n        go: function (position) {\n            if (position === historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current =\n                    position < 0\n                        ? Math.max(history.current.length + position, 0)\n                        : Math.min(history.current.length - 1, position);\n                return history.current[historyPosition.current];\n            });\n        },\n    }); }, [state]);\n    return [state, setState, historyState];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}